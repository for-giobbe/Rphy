# Building a Tree in a ML Framework


---


### intro: 


Before starting this practical set the appropriate working directory and load the necessary libraries in R:


Libraries:


- [Biostrings](https://kasperdanielhansen.github.io/genbioconductor/html/Biostrings.html#overview)
- [phangorn](https://klausvigo.github.io/phangorn/)
- [msa](https://bioconductor.org/packages/devel/bioc/vignettes/msa/inst/doc/msa.pdf)
- [ape](https://emmanuelparadis.github.io/)
- [seqinr](https://www.rdocumentation.org/packages/seqinr/versions/4.2-36)


```
setwd("~/.../RPHY/")
library(Biostrings) 
library(msa)
library(ape)
library(seqinr)
library(phangorn)
library(phytools)
library(apex)
```


Before starting you should have a couple of aligned & filtered MSA, 
or you can grab the ones I am using: 
[CO1.nt.fa](https://github.com/for-giobbe/Rphy/blob/main/sequences/CO1.nt.fa) and 
[ND2.nt.fa](https://github.com/for-giobbe/Rphy/blob/main/sequences/ND2.nt.fa).


---


Maximum likelihood is a general statistical method for estimating parameters of a
probability model: for example a normal distribution can be described by two parameters: 
the mean and variance. Instead, in molecular phylogenetics there are a wide plethora of parameters, which include:


* rates of transitions / trasversions / ... between bases
* base composition
* descriptors of rate heterogeneity across sites
* branchlengths
* the tree itself!


The likelihood is defined as a quantity proportional to the probability of observing the data given the model.
From an operational point of view it consists in finding 
the tree topology that maximizes the probability of observing the given 
sequence data under a specific model of evolution. 


```
P(D|M)
```


If we have a model, we can calculate the probability the observations would have actually been observed as a function of the model. 
We then examine this likelihood function to see where it is at its greatest, and the value of the parameter of
interests at that point is the maximum likelihood estimate of the parameter (_e.g._ the tree and branch lengths).


---


### inferring ML gene trees - unpartitioned analyses:


Let's start by inferring a NJ tree
as we learned during the last lesson: 


```
sequences <- readDNAStringSet("sequences/COX1.nt.fa")
alignment <- as.phyDat(msa(sequences, "Muscle"))
nj_tree <- nj(dist.ml(alignment))
```


Then we conduct a model test to determine the best-fitting evolutionary model, based on AIC:


```
mt = modelTest(alignment, nj_tree, model = c("JC", "K80", "HKY", "GTR"))
var_mt = attr(mt, "env")
evolutionary_model = eval(get(mt$Model[which.min(mt$AIC)], var_mt), var_mt)
```


After this practical, models of sequence evolutions shouldn't be 
something weird ... they are just a bunch of numbers in the end!


```
 loglikelihood: -9424.35 

unconstrained loglikelihood: -5600.794 
Proportion of invariant sites: 0.2121178 
Discrete gamma model
Number of rate categories: 4 
Shape parameter: 0.7337186 

Rate matrix:
          a         c        g         t
a 0.0000000 0.8122448 2.785374 0.6710854
c 0.8122448 0.0000000 1.849860 7.8686555
g 2.7853745 1.8498604 0.000000 1.0000000
t 0.6710854 7.8686555 1.000000 0.0000000

Base frequencies:  
0.466208 0.09923958 0.05858567 0.3759667 
```


- bf - base frequencies
- Q	- Rate matrix:
- inv Proportion of invariant sites:
- k Number of rate categories
- shape Shape parameter

```

initial_pml_tree = pml(tree = nj_tree, data = alignment, model = evolutionary_model$model,
                       bf = evolutionary_model$bf, Q = evolutionary_model$Q, inv = evolutionary_model$inv,
                       k = evolutionary_model$k, shape = evolutionary_model$shape)
```


```
pml_tree = optim.pml(initial_pml_tree, model = evolutionary_model$model, optInv = T, optGamma = F,
                     rearrangement = "stochastic", optBf = F, optQ = F,
                     optEdge = F, optNni = TRUE)
```


### Additional node support metrics - the Transfer Bootstrap Expectation (TBE):


The difference lies in the comparison of the pseudo-trees to the reference tree. 
Rather than the binary presence/absence of a reference branch in the pseudo-trees, TBE uses a “transfer” distance that is measured using the number of taxa that must be transferred (or removed) to make two branches identical


```
bs <- bootstrap.pml(mt, bs=100, optNni=TRUE)
tree_tfbs <- plotBS(fit_mt$tree, bs, type = "n", method = "TBE")
```


---


### inferring ML gene trees - unpartitioned analyses:


---


### conclusions: 


In this lesson we:


* carried out a ML phylogenetic inference on both single loci and concatenation.
* explored metrics of nodal support which are often associated to ML analyses (BP and TBE).
* got confident with the ```.nwk``` format for writing phylogenetic trees.


---


### further reading: 


Some [music](https://youtu.be/pZ12_E5R3qc?t=26) which has been clearly inspired by phylogenetic methods.


---


[0](https://github.com/for-giobbe/Rphy/blob/main/md/0.md)
[1](https://github.com/for-giobbe/Rphy/blob/main/md/1.md)
[2](https://github.com/for-giobbe/Rphy/blob/main/md/2.md)
[3](https://github.com/for-giobbe/Rphy/blob/main/md/3.md)
[4](https://github.com/for-giobbe/Rphy/blob/main/md/4.md)
[5](https://github.com/for-giobbe/Rphy/blob/main/md/5.md)
[6](https://github.com/for-giobbe/Rphy/blob/main/md/6.md)