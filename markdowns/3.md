### Inferring ML phylogenies


---


### intro: 


Before starting this practical set the appropriate working directory and load the necessary libraries in R:


Libraries:


- [Biostrings](https://kasperdanielhansen.github.io/genbioconductor/html/Biostrings.html#overview)
- [phangorn](https://klausvigo.github.io/phangorn/)
- [msa](https://bioconductor.org/packages/devel/bioc/vignettes/msa/inst/doc/msa.pdf)
- [ape](https://emmanuelparadis.github.io/)
- [seqinr](https://www.rdocumentation.org/packages/seqinr/versions/4.2-36)

- [apex](https://cran.r-project.org/web/packages/apex/vignettes/apex.html)

```
setwd("~/.../RPHY/")
library(Biostrings) 
library(msa)
library(ape)
library(seqinr)
library(phangorn)
library(phytools)
library(apex)
```



You should have 2 fasta files, 
or you can use these: 
[CO1.nt.fa](https://github.com/for-giobbe/Rphy/blob/main/sequences/CO1.nt.fa) and 
[ND2.nt.fa](https://github.com/for-giobbe/Rphy/blob/main/sequences/ND2.nt.fa).


---


Maximum likelihood is a general statistical method for estimating parameters of a
probability model: for example a normal distribution can be described by two parameters: 
the mean and variance. Instead, in molecular phylogenetics there are a wide plethora of parameters, which include:


* rates of transitions / trasversions / ... between bases
* base composition
* descriptors of rate heterogeneity across sites
* branchlengths
* the tree itself!


The likelihood is defined as a quantity proportional to the probability of observing the data given the model.
From an operational point of view it consists in finding 
the tree topology that maximizes the probability of observing the given 
sequence data under a specific model of evolution. 


```
P(D|M)
```


If we have a model, we can calculate the probability the observations would have actually been observed as a function of the model. 
We then examine this likelihood function to see where it is at its greatest, and the value of the parameter of
interests at that point is the maximum likelihood estimate of the parameter (_e.g._ the tree and branch lengths).


---


### inferring ML gene trees - unpartitioned analyses:


Let's start by inferring a NJ tree
as we learned during the last lesson: 


```
sequences <- readDNAStringSet("sequences/COX1.nt.fa")
alignment <- as.phyDat(msa(sequences, "Muscle"))
nj_tree <- nj(dist.ml(alignment))
```


Then we conduct a model test to determine the best-fitting evolutionary model, based on AIC:


```
mt = modelTest(alignment, nj_tree, model = c("JC", "K80", "HKY", "GTR"))
var_mt = attr(mt, "env")
evolutionary_model = eval(get(mt$Model[which.min(mt$AIC)], var_mt), var_mt)
```


After this practical, models of sequence evolutions shouldn't be 
something obscure ... they are just a handfull of numbers in the end!


```
 loglikelihood: -3888.591 

unconstrained loglikelihood: -2044.058 
Proportion of invariant sites: 0.5922429 
Discrete gamma model
Number of rate categories: 4 
Shape parameter: 1.964637 

Rate matrix:
          a          c          g         t
a  0.000000  3.4582103 18.2646463  7.133217
c  3.458210  0.0000000  0.5902121 65.082264
g 18.264646  0.5902121  0.0000000  1.000000
t  7.133217 65.0822636  1.0000000  0.000000

Base frequencies:  
0.2812975 0.3796183 0.1498988 0.1891854 
```


Then we can﻿compute the likelihood of a phylogenetic tree 
given a sequence alignment and a model, specifying the following parameters:


- __bf__ for base frequencies
- __Q__ for the rate matrix
- __inv__ for the proportion of invariant sites
- __k__ for the number of rate categories
- __shape__ for the gamma distribution shape parameter


```
initial_pml_tree = pml(tree = nj_tree, data = alignment, 
                       model = evolutionary_model$model,
                       bf = evolutionary_model$bf, 
                       Q = evolutionary_model$Q, 
                       inv = evolutionary_model$inv,
                       k = evolutionary_model$k, 
                       shape = evolutionary_model$shape)
```


```
pml_tree = optim.pml(initial_pml_tree, 
					 model = evolutionary_model$model, 
            		 optInv = T, 
                     optGamma = F,
                     optBf = F, 
                     optQ = F,
                     optEdge = F,
                     optNni = TRUE,
                     rearrangement = "NNI")
```


### Additional node support metrics - the Transfer Bootstrap Expectation (TBE):


The difference lies in the comparison of the pseudo-trees to the reference tree. 
Rather than the binary presence/absence of a reference branch in the pseudo-trees, TBE uses a “transfer” distance that is measured using the number of taxa that must be transferred (or removed) to make two branches identical


```
bs <- bootstrap.pml(mt, bs=100, optNni=TRUE)
tree_tfbs <- plotBS(fit_mt$tree, bs, type = "n", method = "TBE")
```


---


### inferring ML species trees - partitioned analyses:


```
genes <- list(gene1=as.DNAbin(alignment_1), as.DNAbin(alignment_2))
concatenate(genes)
x <- new("multidna", genes)
```

---


### conclusions: 


In this lesson we:


* carried out a ML phylogenetic inference on both single loci and concatenation.
* explored metrics of nodal support which are often associated to ML analyses (BP and TBE).


---


### further reading: 


Some [music](https://youtu.be/pZ12_E5R3qc?t=26) which has been clearly inspired by phylogenetic methods.

Nice [paper](https://academic.oup.com/sysbio/article/72/6/1280/7240218) on the robustness of BP versus TBE 

---


[0](https://github.com/for-giobbe/Rphy/blob/main/markdowns/0.md)
[1](https://github.com/for-giobbe/Rphy/blob/main/markdowns/1.md)
[2](https://github.com/for-giobbe/Rphy/blob/main/markdowns/2.md)
[3](https://github.com/for-giobbe/Rphy/blob/main/markdowns/3.md)
[4](https://github.com/for-giobbe/Rphy/blob/main/markdowns/4.md)
[5](https://github.com/for-giobbe/Rphy/blob/main/markdowns/5.md)
[6](https://github.com/for-giobbe/Rphy/blob/main/markdowns/6.md)